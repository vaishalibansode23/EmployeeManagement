"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Container = void 0;
const common_1 = require("@inversifyjs/common");
const core_1 = require("@inversifyjs/core");
const isBindingIdentifier_1 = require("../../binding/calculations/isBindingIdentifier");
const BindingFluentSyntaxImplementation_1 = require("../../binding/models/BindingFluentSyntaxImplementation");
const getFirstIterableResult_1 = require("../../common/calculations/getFirstIterableResult");
const InversifyContainerError_1 = require("../../error/models/InversifyContainerError");
const InversifyContainerErrorKind_1 = require("../../error/models/InversifyContainerErrorKind");
const DEFAULT_DEFAULT_SCOPE = core_1.bindingScopeValues.Transient;
class Container {
    #activationService;
    #bindingService;
    #deactivationParams;
    #deactivationService;
    #getActivationsResolutionParam;
    #getBindingsPlanParams;
    #options;
    #planResultCacheService;
    #resolutionContext;
    #setBindingParamsPlan;
    #snapshots;
    constructor(options) {
        this.#deactivationParams = this.#buildDeactivationParams();
        this.#getActivationsResolutionParam = (serviceIdentifier) => this.#activationService.get(serviceIdentifier);
        this.#planResultCacheService = new core_1.PlanResultCacheService();
        this.#resolutionContext = this.#buildResolutionContext();
        if (options?.parent === undefined) {
            this.#activationService = core_1.ActivationsService.build(undefined);
            this.#bindingService = core_1.BindingService.build(undefined);
            this.#deactivationService = core_1.DeactivationsService.build(undefined);
        }
        else {
            this.#activationService = core_1.ActivationsService.build(options.parent.#activationService);
            this.#bindingService = core_1.BindingService.build(options.parent.#bindingService);
            this.#deactivationService = core_1.DeactivationsService.build(options.parent.#deactivationService);
            options.parent.#planResultCacheService.subscribe(this.#planResultCacheService);
        }
        this.#getBindingsPlanParams = this.#bindingService.get.bind(this.#bindingService);
        this.#setBindingParamsPlan = this.#setBinding.bind(this);
        this.#options = {
            autobind: options?.autobind ?? false,
            defaultScope: options?.defaultScope ?? DEFAULT_DEFAULT_SCOPE,
        };
        this.#snapshots = [];
    }
    bind(serviceIdentifier) {
        return new BindingFluentSyntaxImplementation_1.BindToFluentSyntaxImplementation((binding) => {
            this.#setBinding(binding);
        }, undefined, this.#options.defaultScope, serviceIdentifier);
    }
    get(serviceIdentifier, options) {
        const planResult = this.#buildPlanResult(false, serviceIdentifier, options);
        const resolvedValue = this.#getFromPlanResult(planResult);
        if ((0, common_1.isPromise)(resolvedValue)) {
            throw new InversifyContainerError_1.InversifyContainerError(InversifyContainerErrorKind_1.InversifyContainerErrorKind.invalidOperation, `Unexpected asyncronous service when resolving service "${(0, common_1.stringifyServiceIdentifier)(serviceIdentifier)}"`);
        }
        return resolvedValue;
    }
    getAll(serviceIdentifier, options) {
        const planResult = this.#buildPlanResult(true, serviceIdentifier, options);
        const resolvedValue = this.#getFromPlanResult(planResult);
        if ((0, common_1.isPromise)(resolvedValue)) {
            throw new InversifyContainerError_1.InversifyContainerError(InversifyContainerErrorKind_1.InversifyContainerErrorKind.invalidOperation, `Unexpected asyncronous service when resolving service "${(0, common_1.stringifyServiceIdentifier)(serviceIdentifier)}"`);
        }
        return resolvedValue;
    }
    async getAllAsync(serviceIdentifier, options) {
        const planResult = this.#buildPlanResult(true, serviceIdentifier, options);
        return this.#getFromPlanResult(planResult);
    }
    async getAsync(serviceIdentifier, options) {
        const planResult = this.#buildPlanResult(false, serviceIdentifier, options);
        return this.#getFromPlanResult(planResult);
    }
    isBound(serviceIdentifier, options) {
        const bindings = this.#bindingService.get(serviceIdentifier);
        return this.#isAnyValidBinding(serviceIdentifier, bindings, options);
    }
    isCurrentBound(serviceIdentifier, options) {
        const bindings = this.#bindingService.getNonParentBindings(serviceIdentifier);
        return this.#isAnyValidBinding(serviceIdentifier, bindings, options);
    }
    async load(...modules) {
        await Promise.all(this.#load(...modules));
    }
    loadSync(...modules) {
        const results = this.#load(...modules);
        for (const result of results) {
            if (result !== undefined) {
                throw new InversifyContainerError_1.InversifyContainerError(InversifyContainerErrorKind_1.InversifyContainerErrorKind.invalidOperation, 'Unexpected asyncronous module load. Consider using Container.load() instead.');
            }
        }
    }
    onActivation(serviceIdentifier, activation) {
        this.#activationService.add(activation, {
            serviceId: serviceIdentifier,
        });
    }
    onDeactivation(serviceIdentifier, deactivation) {
        this.#deactivationService.add(deactivation, {
            serviceId: serviceIdentifier,
        });
    }
    restore() {
        const snapshot = this.#snapshots.pop();
        if (snapshot === undefined) {
            throw new InversifyContainerError_1.InversifyContainerError(InversifyContainerErrorKind_1.InversifyContainerErrorKind.invalidOperation, 'No snapshot available to restore');
        }
        this.#activationService = snapshot.activationService;
        this.#bindingService = snapshot.bindingService;
        this.#deactivationService = snapshot.deactivationService;
        this.#resetComputedProperties();
    }
    async rebind(serviceIdentifier) {
        await this.unbind(serviceIdentifier);
        return this.bind(serviceIdentifier);
    }
    rebindSync(serviceIdentifier) {
        this.unbindSync(serviceIdentifier);
        return this.bind(serviceIdentifier);
    }
    snapshot() {
        this.#snapshots.push({
            activationService: this.#activationService.clone(),
            bindingService: this.#bindingService.clone(),
            deactivationService: this.#deactivationService.clone(),
        });
    }
    async unbind(identifier) {
        await this.#unbind(identifier);
    }
    async unbindAll() {
        const nonParentBoundServiceIds = [
            ...this.#bindingService.getNonParentBoundServices(),
        ];
        await Promise.all(nonParentBoundServiceIds.map(async (serviceId) => (0, core_1.resolveServiceDeactivations)(this.#deactivationParams, serviceId)));
        /*
         * Removing service related objects here so unbindAll is deterministic.
         *
         * Removing service related objects as soon as resolveModuleDeactivations takes
         * effect leads to module deactivations not triggering previously deleted
         * deactivations, introducing non determinism depending in the order in which
         * services are deactivated.
         */
        for (const serviceId of nonParentBoundServiceIds) {
            this.#activationService.removeAllByServiceId(serviceId);
            this.#bindingService.removeAllByServiceId(serviceId);
            this.#deactivationService.removeAllByServiceId(serviceId);
        }
        this.#planResultCacheService.clearCache();
    }
    unbindSync(identifier) {
        const result = this.#unbind(identifier);
        if (result !== undefined) {
            this.#throwUnexpectedAsyncUnbindOperation(identifier);
        }
    }
    async unload(...modules) {
        await Promise.all(this.#unload(...modules));
        /*
         * Removing module related objects here so unload is deterministic.
         *
         * Removing modules as soon as resolveModuleDeactivations takes effect leads to
         * module deactivations not triggering previously deleted deactivations,
         * introducing non determinism depending in the order in which modules are
         * deactivated.
         */
        this.#clearAfterUnloadModules(modules);
    }
    unloadSync(...modules) {
        const results = this.#unload(...modules);
        for (const result of results) {
            if (result !== undefined) {
                throw new InversifyContainerError_1.InversifyContainerError(InversifyContainerErrorKind_1.InversifyContainerErrorKind.invalidOperation, 'Unexpected asyncronous module unload. Consider using Container.unload() instead.');
            }
        }
        /*
         * Removing module related objects here so unload is deterministic.
         *
         * Removing modules as soon as resolveModuleDeactivations takes effect leads to
         * module deactivations not triggering previously deleted deactivations,
         * introducing non determinism depending in the order in which modules are
         * deactivated.
         */
        this.#clearAfterUnloadModules(modules);
    }
    #buildContainerModuleLoadOptions(moduleId) {
        return {
            bind: (serviceIdentifier) => {
                return new BindingFluentSyntaxImplementation_1.BindToFluentSyntaxImplementation((binding) => {
                    this.#setBinding(binding);
                }, moduleId, this.#options.defaultScope, serviceIdentifier);
            },
            isBound: this.isBound.bind(this),
            onActivation: (serviceIdentifier, activation) => {
                this.#activationService.add(activation, {
                    moduleId,
                    serviceId: serviceIdentifier,
                });
            },
            onDeactivation: (serviceIdentifier, deactivation) => {
                this.#deactivationService.add(deactivation, {
                    moduleId,
                    serviceId: serviceIdentifier,
                });
            },
            rebind: this.rebind.bind(this),
            rebindSync: this.rebindSync.bind(this),
            unbind: this.unbind.bind(this),
            unbindSync: this.unbindSync.bind(this),
        };
    }
    #buildDeactivationParams() {
        return {
            getBindings: (serviceIdentifier) => this.#bindingService.get(serviceIdentifier),
            getBindingsFromModule: (moduleId) => this.#bindingService.getByModuleId(moduleId),
            getClassMetadata: core_1.getClassMetadata,
            getDeactivations: (serviceIdentifier) => this.#deactivationService.get(serviceIdentifier),
        };
    }
    #buildGetPlanOptions(isMultiple, serviceIdentifier, options) {
        return {
            isMultiple,
            name: options?.name,
            optional: options?.optional,
            serviceIdentifier,
            tag: options?.tag,
        };
    }
    #buildPlanParams(serviceIdentifier, isMultiple, options) {
        const planParams = {
            autobindOptions: (options?.autobind ?? this.#options.autobind)
                ? {
                    scope: this.#options.defaultScope,
                }
                : undefined,
            getBindings: this.#getBindingsPlanParams,
            getClassMetadata: core_1.getClassMetadata,
            rootConstraints: {
                isMultiple,
                serviceIdentifier,
            },
            servicesBranch: [],
            setBinding: this.#setBindingParamsPlan,
        };
        this.#handlePlanParamsRootConstraints(planParams, options);
        return planParams;
    }
    #buildPlanResult(isMultiple, serviceIdentifier, options) {
        const getPlanOptions = this.#buildGetPlanOptions(isMultiple, serviceIdentifier, options);
        const planResultFromCache = this.#planResultCacheService.get(getPlanOptions);
        if (planResultFromCache !== undefined) {
            return planResultFromCache;
        }
        const planResult = (0, core_1.plan)(this.#buildPlanParams(serviceIdentifier, isMultiple, options));
        this.#planResultCacheService.set(getPlanOptions, planResult);
        return planResult;
    }
    #buildResolutionContext() {
        return {
            get: this.get.bind(this),
            getAll: this.getAll.bind(this),
            getAllAsync: this.getAllAsync.bind(this),
            getAsync: this.getAsync.bind(this),
        };
    }
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-parameters
    #getFromPlanResult(planResult) {
        return (0, core_1.resolve)({
            context: this.#resolutionContext,
            getActivations: this.#getActivationsResolutionParam,
            planResult,
            requestScopeCache: new Map(),
        });
    }
    #handlePlanParamsRootConstraints(planParams, options) {
        if (options === undefined) {
            return;
        }
        if (options.name !== undefined) {
            planParams.rootConstraints.name = options.name;
        }
        if (options.optional === true) {
            planParams.rootConstraints.isOptional = true;
        }
        if (options.tag !== undefined) {
            planParams.rootConstraints.tag = {
                key: options.tag.key,
                value: options.tag.value,
            };
        }
    }
    #isAnyValidBinding(serviceIdentifier, bindings, options) {
        if (bindings === undefined) {
            return false;
        }
        const bindingConstraints = {
            getAncestor: () => undefined,
            name: options?.name,
            serviceIdentifier,
            tags: new Map(),
        };
        if (options?.tag !== undefined) {
            bindingConstraints.tags.set(options.tag.key, options.tag.value);
        }
        for (const binding of bindings) {
            if (binding.isSatisfiedBy(bindingConstraints)) {
                return true;
            }
        }
        return false;
    }
    #load(...modules) {
        return modules.map((module) => module.load(this.#buildContainerModuleLoadOptions(module.id)));
    }
    #unload(...modules) {
        return modules.map((module) => (0, core_1.resolveModuleDeactivations)(this.#deactivationParams, module.id));
    }
    #resetComputedProperties() {
        this.#planResultCacheService.clearCache();
        this.#getActivationsResolutionParam = (serviceIdentifier) => this.#activationService.get(serviceIdentifier);
        this.#getBindingsPlanParams = this.#bindingService.get.bind(this.#bindingService);
        this.#resolutionContext = this.#buildResolutionContext();
        this.#setBindingParamsPlan = this.#setBinding.bind(this);
    }
    #setBinding(binding) {
        this.#bindingService.set(binding);
        this.#planResultCacheService.clearCache();
    }
    #throwUnexpectedAsyncUnbindOperation(identifier) {
        let errorMessage;
        if ((0, isBindingIdentifier_1.isBindingIdentifier)(identifier)) {
            const bindingsById = this.#bindingService.getById(identifier.id);
            const bindingServiceIdentifier = (0, getFirstIterableResult_1.getFirstIterableResult)(bindingsById)?.serviceIdentifier;
            if (bindingServiceIdentifier === undefined) {
                errorMessage =
                    'Unexpected asyncronous deactivation when unbinding binding identifier. Consider using Container.unbind() instead.';
            }
            else {
                errorMessage = `Unexpected asyncronous deactivation when unbinding "${(0, common_1.stringifyServiceIdentifier)(bindingServiceIdentifier)}" binding. Consider using Container.unbind() instead.`;
            }
        }
        else {
            errorMessage = `Unexpected asyncronous deactivation when unbinding "${(0, common_1.stringifyServiceIdentifier)(identifier)}" service. Consider using Container.unbind() instead.`;
        }
        throw new InversifyContainerError_1.InversifyContainerError(InversifyContainerErrorKind_1.InversifyContainerErrorKind.invalidOperation, errorMessage);
    }
    #unbind(identifier) {
        if ((0, isBindingIdentifier_1.isBindingIdentifier)(identifier)) {
            return this.#unbindBindingIdentifier(identifier);
        }
        return this.#unbindServiceIdentifier(identifier);
    }
    #unbindBindingIdentifier(identifier) {
        const bindings = this.#bindingService.getById(identifier.id);
        const result = (0, core_1.resolveBindingsDeactivations)(this.#deactivationParams, bindings);
        if (result === undefined) {
            this.#clearAfterUnbindBindingIdentifier(identifier);
        }
        else {
            return result.then(() => {
                this.#clearAfterUnbindBindingIdentifier(identifier);
            });
        }
    }
    #clearAfterUnbindBindingIdentifier(identifier) {
        this.#bindingService.removeById(identifier.id);
        this.#planResultCacheService.clearCache();
    }
    #clearAfterUnloadModules(modules) {
        for (const module of modules) {
            this.#activationService.removeAllByModuleId(module.id);
            this.#bindingService.removeAllByModuleId(module.id);
            this.#deactivationService.removeAllByModuleId(module.id);
        }
        this.#planResultCacheService.clearCache();
    }
    #unbindServiceIdentifier(identifier) {
        const result = (0, core_1.resolveServiceDeactivations)(this.#deactivationParams, identifier);
        if (result === undefined) {
            this.#clearAfterUnbindServiceIdentifier(identifier);
        }
        else {
            return result.then(() => {
                this.#clearAfterUnbindServiceIdentifier(identifier);
            });
        }
    }
    #clearAfterUnbindServiceIdentifier(identifier) {
        this.#activationService.removeAllByServiceId(identifier);
        this.#bindingService.removeAllByServiceId(identifier);
        this.#deactivationService.removeAllByServiceId(identifier);
        this.#planResultCacheService.clearCache();
    }
}
exports.Container = Container;
//# sourceMappingURL=Container.js.map
import"reflect-metadata";import{getOwnReflectMetadata as i,setReflectMetadata as e,updateOwnReflectMetadata as n}from"@inversifyjs/reflect-metadata-utils";import{LazyServiceIdentifier as t,isPromise as s,stringifyServiceIdentifier as r}from"@inversifyjs/common";import{getClassMetadata as a,bindingTypeValues as o,bindingScopeValues as d,ResolvedValueElementMetadataKind as c,PlanResultCacheService as l,ActivationsService as u,BindingService as h,DeactivationsService as v,resolveServiceDeactivations as g,plan as b,resolve as f,resolveModuleDeactivations as S,resolveBindingsDeactivations as p}from"@inversifyjs/core";const y="@inversifyjs/container/bindingId";class m{#i;#e;constructor(t){this.#i=function(){const t=i(Object,y)??0;return t===Number.MAX_SAFE_INTEGER?e(Object,y,Number.MIN_SAFE_INTEGER):n(Object,y,(()=>t),(i=>i+1)),t}(),this.#e=t}get id(){return this.#i}load(i){return this.#e(i)}}const w=Symbol.for("@inversifyjs/container/bindingIdentifier");function I(i){return"object"==typeof i&&null!==i&&!0===i[w]}class A{static always=i=>!0}const P="@inversifyjs/container/bindingId";function B(){const t=i(Object,P)??0;return t===Number.MAX_SAFE_INTEGER?e(Object,P,Number.MIN_SAFE_INTEGER):n(Object,P,(()=>t),(i=>i+1)),t}function C(i){return{[w]:!0,id:i.id}}function R(i){return e=>{for(let n=e.getAncestor();void 0!==n;n=n.getAncestor())if(i(n))return!0;return!1}}function M(i){return e=>e.name===i}function x(i){return e=>e.serviceIdentifier===i}function O(i,e){return n=>n.tags.has(i)&&n.tags.get(i)===e}function N(i){return void 0===i.name&&0===i.tags.size}function F(i){const e=R(i);return i=>!e(i)}function U(i){return e=>{const n=e.getAncestor();return void 0===n||!i(n)}}function j(i){return e=>{const n=e.getAncestor();return void 0!==n&&i(n)}}class k{#n;constructor(i){this.#n=i}getIdentifier(){return C(this.#n)}inRequestScope(){return this.#n.scope=d.Request,new V(this.#n)}inSingletonScope(){return this.#n.scope=d.Singleton,new V(this.#n)}inTransientScope(){return this.#n.scope=d.Transient,new V(this.#n)}}class D{#t;#s;#r;#a;constructor(i,e,n,t){this.#t=i,this.#s=e,this.#r=n,this.#a=t}to(i){const e=a(i),n={cache:{isRight:!1,value:void 0},id:B(),implementationType:i,isSatisfiedBy:A.always,moduleId:this.#s,onActivation:void 0,onDeactivation:void 0,scope:e.scope??this.#r,serviceIdentifier:this.#a,type:o.Instance};return this.#t(n),new _(n)}toSelf(){if("function"!=typeof this.#a)throw new Error('"toSelf" function can only be applied when a newable function is used as service identifier');return this.to(this.#a)}toConstantValue(i){const e={cache:{isRight:!1,value:void 0},id:B(),isSatisfiedBy:A.always,moduleId:this.#s,onActivation:void 0,onDeactivation:void 0,scope:d.Singleton,serviceIdentifier:this.#a,type:o.ConstantValue,value:i};return this.#t(e),new V(e)}toDynamicValue(i){const e={cache:{isRight:!1,value:void 0},id:B(),isSatisfiedBy:A.always,moduleId:this.#s,onActivation:void 0,onDeactivation:void 0,scope:this.#r,serviceIdentifier:this.#a,type:o.DynamicValue,value:i};return this.#t(e),new _(e)}toResolvedValue(i,e){const n={cache:{isRight:!1,value:void 0},factory:i,id:B(),isSatisfiedBy:A.always,metadata:this.#o(e),moduleId:this.#s,onActivation:void 0,onDeactivation:void 0,scope:this.#r,serviceIdentifier:this.#a,type:o.ResolvedValue};return this.#t(n),new _(n)}toFactory(i){const e={cache:{isRight:!1,value:void 0},factory:i,id:B(),isSatisfiedBy:A.always,moduleId:this.#s,onActivation:void 0,onDeactivation:void 0,scope:d.Singleton,serviceIdentifier:this.#a,type:o.Factory};return this.#t(e),new V(e)}toProvider(i){const e={cache:{isRight:!1,value:void 0},id:B(),isSatisfiedBy:A.always,moduleId:this.#s,onActivation:void 0,onDeactivation:void 0,provider:i,scope:d.Singleton,serviceIdentifier:this.#a,type:o.Provider};return this.#t(e),new V(e)}toService(i){const e={id:B(),isSatisfiedBy:A.always,moduleId:this.#s,serviceIdentifier:this.#a,targetServiceIdentifier:i,type:o.ServiceRedirection};this.#t(e)}#o(i){return{arguments:(i??[]).map((i=>function(i){return"object"==typeof i&&!t.is(i)}(i)?{kind:!0===i.isMultiple?c.multipleInjection:c.singleInjection,name:i.name,optional:i.optional??!1,tags:new Map((i.tags??[]).map((i=>[i.key,i.value]))),value:i.serviceIdentifier}:{kind:c.singleInjection,name:void 0,optional:!1,tags:new Map,value:i}))}}}class E{#n;constructor(i){this.#n=i}getIdentifier(){return C(this.#n)}onActivation(i){return this.#n.onActivation=i,new T(this.#n)}onDeactivation(i){return this.#n.onDeactivation=i,new T(this.#n)}}class T{#n;constructor(i){this.#n=i}getIdentifier(){return C(this.#n)}when(i){return this.#n.isSatisfiedBy=i,new E(this.#n)}whenAnyAncestor(i){return this.when(R(i))}whenAnyAncestorIs(i){return this.when(R(x(i)))}whenAnyAncestorNamed(i){return this.when(function(i){return R(M(i))}(i))}whenAnyAncestorTagged(i,e){return this.when(function(i,e){return R(O(i,e))}(i,e))}whenDefault(){return this.when(N)}whenNamed(i){return this.when(M(i))}whenNoParent(i){return this.when(U(i))}whenNoParentIs(i){return this.when(U(x(i)))}whenNoParentNamed(i){return this.when(function(i){return U(M(i))}(i))}whenNoParentTagged(i,e){return this.when(function(i,e){return U(O(i,e))}(i,e))}whenParent(i){return this.when(j(i))}whenParentIs(i){return this.when(j(x(i)))}whenParentNamed(i){return this.when(function(i){return j(M(i))}(i))}whenParentTagged(i,e){return this.when(function(i,e){return j(O(i,e))}(i,e))}whenTagged(i,e){return this.when(O(i,e))}whenNoAncestor(i){return this.when(F(i))}whenNoAncestorIs(i){return this.when(F(x(i)))}whenNoAncestorNamed(i){return this.when(function(i){return F(M(i))}(i))}whenNoAncestorTagged(i,e){return this.when(function(i,e){return F(O(i,e))}(i,e))}}class V extends T{#d;constructor(i){super(i),this.#d=new E(i)}onActivation(i){return this.#d.onActivation(i)}onDeactivation(i){return this.#d.onDeactivation(i)}}class _ extends V{#c;constructor(i){super(i),this.#c=new k(i)}inRequestScope(){return this.#c.inRequestScope()}inSingletonScope(){return this.#c.inSingletonScope()}inTransientScope(){return this.#c.inTransientScope()}}const G=Symbol.for("@inversifyjs/container/InversifyContainerError");class q extends Error{[G];kind;constructor(i,e,n){super(e,n),this[G]=!0,this.kind=i}static is(i){return"object"==typeof i&&null!==i&&!0===i[G]}static isErrorOfKind(i,e){return q.is(i)&&i.kind===e}}var $;!function(i){i[i.invalidOperation=0]="invalidOperation"}($||($={}));const L=d.Transient;class X{#l;#u;#h;#v;#g;#b;#f;#S;#p;#y;#m;constructor(i){this.#h=this.#w(),this.#g=i=>this.#l.get(i),this.#S=new l,this.#p=this.#I(),void 0===i?.parent?(this.#l=u.build(void 0),this.#u=h.build(void 0),this.#v=v.build(void 0)):(this.#l=u.build(i.parent.#l),this.#u=h.build(i.parent.#u),this.#v=v.build(i.parent.#v),i.parent.#S.subscribe(this.#S)),this.#b=this.#u.get.bind(this.#u),this.#y=this.#A.bind(this),this.#f={autobind:i?.autobind??!1,defaultScope:i?.defaultScope??L},this.#m=[]}bind(i){return new D((i=>{this.#A(i)}),void 0,this.#f.defaultScope,i)}get(i,e){const n=this.#P(!1,i,e),t=this.#B(n);if(s(t))throw new q($.invalidOperation,`Unexpected asyncronous service when resolving service "${r(i)}"`);return t}getAll(i,e){const n=this.#P(!0,i,e),t=this.#B(n);if(s(t))throw new q($.invalidOperation,`Unexpected asyncronous service when resolving service "${r(i)}"`);return t}async getAllAsync(i,e){const n=this.#P(!0,i,e);return this.#B(n)}async getAsync(i,e){const n=this.#P(!1,i,e);return this.#B(n)}isBound(i,e){const n=this.#u.get(i);return this.#C(i,n,e)}isCurrentBound(i,e){const n=this.#u.getNonParentBindings(i);return this.#C(i,n,e)}async load(...i){await Promise.all(this.#e(...i))}loadSync(...i){const e=this.#e(...i);for(const i of e)if(void 0!==i)throw new q($.invalidOperation,"Unexpected asyncronous module load. Consider using Container.load() instead.")}onActivation(i,e){this.#l.add(e,{serviceId:i})}onDeactivation(i,e){this.#v.add(e,{serviceId:i})}restore(){const i=this.#m.pop();if(void 0===i)throw new q($.invalidOperation,"No snapshot available to restore");this.#l=i.activationService,this.#u=i.bindingService,this.#v=i.deactivationService,this.#R()}async rebind(i){return await this.unbind(i),this.bind(i)}rebindSync(i){return this.unbindSync(i),this.bind(i)}snapshot(){this.#m.push({activationService:this.#l.clone(),bindingService:this.#u.clone(),deactivationService:this.#v.clone()})}async unbind(i){await this.#M(i)}async unbindAll(){const i=[...this.#u.getNonParentBoundServices()];await Promise.all(i.map((async i=>g(this.#h,i))));for(const e of i)this.#l.removeAllByServiceId(e),this.#u.removeAllByServiceId(e),this.#v.removeAllByServiceId(e);this.#S.clearCache()}unbindSync(i){void 0!==this.#M(i)&&this.#x(i)}async unload(...i){await Promise.all(this.#O(...i)),this.#N(i)}unloadSync(...i){const e=this.#O(...i);for(const i of e)if(void 0!==i)throw new q($.invalidOperation,"Unexpected asyncronous module unload. Consider using Container.unload() instead.");this.#N(i)}#F(i){return{bind:e=>new D((i=>{this.#A(i)}),i,this.#f.defaultScope,e),isBound:this.isBound.bind(this),onActivation:(e,n)=>{this.#l.add(n,{moduleId:i,serviceId:e})},onDeactivation:(e,n)=>{this.#v.add(n,{moduleId:i,serviceId:e})},rebind:this.rebind.bind(this),rebindSync:this.rebindSync.bind(this),unbind:this.unbind.bind(this),unbindSync:this.unbindSync.bind(this)}}#w(){return{getBindings:i=>this.#u.get(i),getBindingsFromModule:i=>this.#u.getByModuleId(i),getClassMetadata:a,getDeactivations:i=>this.#v.get(i)}}#U(i,e,n){return{isMultiple:i,name:n?.name,optional:n?.optional,serviceIdentifier:e,tag:n?.tag}}#j(i,e,n){const t={autobindOptions:n?.autobind??this.#f.autobind?{scope:this.#f.defaultScope}:void 0,getBindings:this.#b,getClassMetadata:a,rootConstraints:{isMultiple:e,serviceIdentifier:i},servicesBranch:[],setBinding:this.#y};return this.#k(t,n),t}#P(i,e,n){const t=this.#U(i,e,n),s=this.#S.get(t);if(void 0!==s)return s;const r=b(this.#j(e,i,n));return this.#S.set(t,r),r}#I(){return{get:this.get.bind(this),getAll:this.getAll.bind(this),getAllAsync:this.getAllAsync.bind(this),getAsync:this.getAsync.bind(this)}}#B(i){return f({context:this.#p,getActivations:this.#g,planResult:i,requestScopeCache:new Map})}#k(i,e){void 0!==e&&(void 0!==e.name&&(i.rootConstraints.name=e.name),!0===e.optional&&(i.rootConstraints.isOptional=!0),void 0!==e.tag&&(i.rootConstraints.tag={key:e.tag.key,value:e.tag.value}))}#C(i,e,n){if(void 0===e)return!1;const t={getAncestor:()=>{},name:n?.name,serviceIdentifier:i,tags:new Map};void 0!==n?.tag&&t.tags.set(n.tag.key,n.tag.value);for(const i of e)if(i.isSatisfiedBy(t))return!0;return!1}#e(...i){return i.map((i=>i.load(this.#F(i.id))))}#O(...i){return i.map((i=>S(this.#h,i.id)))}#R(){this.#S.clearCache(),this.#g=i=>this.#l.get(i),this.#b=this.#u.get.bind(this.#u),this.#p=this.#I(),this.#y=this.#A.bind(this)}#A(i){this.#u.set(i),this.#S.clearCache()}#x(i){let e;if(I(i)){const t=this.#u.getById(i.id),s=(n=t,function(i){if(void 0===i)return;const e=i.next();return!0!==e.done?e.value:void 0}(n?.[Symbol.iterator]()))?.serviceIdentifier;e=void 0===s?"Unexpected asyncronous deactivation when unbinding binding identifier. Consider using Container.unbind() instead.":`Unexpected asyncronous deactivation when unbinding "${r(s)}" binding. Consider using Container.unbind() instead.`}else e=`Unexpected asyncronous deactivation when unbinding "${r(i)}" service. Consider using Container.unbind() instead.`;var n;throw new q($.invalidOperation,e)}#M(i){return I(i)?this.#D(i):this.#E(i)}#D(i){const e=this.#u.getById(i.id),n=p(this.#h,e);if(void 0!==n)return n.then((()=>{this.#T(i)}));this.#T(i)}#T(i){this.#u.removeById(i.id),this.#S.clearCache()}#N(i){for(const e of i)this.#l.removeAllByModuleId(e.id),this.#u.removeAllByModuleId(e.id),this.#v.removeAllByModuleId(e.id);this.#S.clearCache()}#E(i){const e=g(this.#h,i);if(void 0!==e)return e.then((()=>{this.#V(i)}));this.#V(i)}#V(i){this.#l.removeAllByServiceId(i),this.#u.removeAllByServiceId(i),this.#v.removeAllByServiceId(i),this.#S.clearCache()}}export{X as Container,m as ContainerModule,q as InversifyContainerError,$ as InversifyContainerErrorKind};
//# sourceMappingURL=index.js.map

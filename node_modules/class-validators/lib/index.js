"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validate = validate;
exports.validateMethod = validateMethod;
exports.t = void 0;

var _validateIndividual = _interopRequireDefault(require("./validateIndividual"));

var t = _interopRequireWildcard(require("./types"));

exports.t = t;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// NOTE: We don't validate any extra args
function validate(types, values, method = null, className = null, aliases = []) {
  let prefix = method ? `${method}() expects` : 'expected';

  if (className) {
    prefix = `${className}#${prefix}`;
  }

  types.forEach(function (type, index) {
    const value = values[index];
    const alias = aliases[index] || `Parameter ${index + 1}`;

    try {
      (0, _validateIndividual.default)(type, value, index, types, values, false);
    } catch (error) {
      error.message = `${prefix} ${alias}${error.message}`;
      throw error;
    }
  });
}

function validateMethod(...types) {
  return function (target, key, descriptor) {
    const className = target.constructor.name || 'Object';
    validate([Function], [descriptor.value], 'validateMethod', null, [`${className}#${key}`]);
    const realCallback = descriptor.value;

    const validationCallback = function validationCallback(...values) {
      validate(types, values, key, className);
      return realCallback(...values);
    };

    Object.setPrototypeOf(validationCallback.prototype, target); // eslint-disable-next-line no-param-reassign

    descriptor.value = validationCallback;
    return descriptor;
  };
}